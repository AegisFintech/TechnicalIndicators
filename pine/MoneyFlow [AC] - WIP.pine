//@version=6

indicator("Money Flow Profile [LuxAlgo]", "L", true, max_bars_back = 1500, max_boxes_count = 500, max_lines_count = 500)

rpLN = last_bar_index > 200 ? 200 - 1 : last_bar_index, rpW = 13 / 100
type bar
    float o = open
    float h = high
    float l = low
    float c = close
    float v = volume
    int   i = bar_index
bar b = bar.new()
rpVST = array.new_float(25, 0.), rpVSB = rpVST, rpVSD = rpVST
var dRP = array.new_box(), var pocPoints = array.new<chart.point>()
var color llC = na, var color lsC = na
bull = b.c > b.o, nzV  = nz(b.v)
var float pLST = na, var float pHST = na

if b.i == last_bar_index - rpLN
    pLST := b.l, pHST := b.h
else if b.i > last_bar_index - rpLN
    pLST := math.min(b.l, pLST), pHST := math.max(b.h, pHST)
pSTP = (pHST - pLST) / 25

if barstate.islast and not na(nzV) and not timeframe.isseconds and rpLN > 0 and pSTP > 0 and nzV > 0
    if dRP.size() > 0
        for i = 0 to dRP.size() - 1
            box.delete(dRP.shift())
    if pocPoints.size() > 0
        pocPoints.clear()
    a_allPolylines = polyline.all
    if array.size(a_allPolylines) > 0
        for i = 0 to array.size(a_allPolylines) - 1
            polyline.delete(a_allPolylines.get(i))
    for bI = rpLN to 0
        i = 0
        for pLL = pLST to pHST - pSTP by pSTP
            if (b[bI]).h >= pLL and (b[bI]).i < pLL + pSTP
                vPOR = if (b[bI]).i >= pLL and (b[bI]).h > pLL + pSTP
                    (pLL + pSTP - (b[bI]).i) / ((b[bI]).h - (b[bI]).i)
                else if (b[bI]).h <= pLL + pSTP and (b[bI]).i < pLL
                    ((b[bI]).h - pLL) / ((b[bI]).h - (b[bI]).i)
                else if ((b[bI]).i >= pLL and (b[bI]).h <= pLL + pSTP)
                    1
                else
                    pSTP / ((b[bI]).h - (b[bI]).i)
                rpVST.set(i, rpVST.get(i) + nzV[bI] * vPOR )
                if bull[bI]
                    rpVSB.set(i, rpVSB.get(i) + nzV[bI] * vPOR )
            i += 1
    pocPoints.push(chart.point.from_index((b[rpLN]).i, pLST + (rpVST.indexof(rpVST.max()) + .5) * pSTP))
    pocPoints.push(chart.point.from_index(b.i, pLST + (rpVST.indexof(rpVST.max()) + .5) * pSTP))

    for i = 0 to 25 - 1
        bbp  = 2 * rpVSB.get(i) - rpVST.get(i)
        rpVSD.set(i, rpVSD.get(i) + bbp * (bbp > 0 ? 1 : -1) )
        sBI = b.i + rpLN * rpW + int(rpLN * rpW / 3)
        dRP.push(box.new(sBI - 1 + 13, pLST + (i + .1) * pSTP, sBI - int(rpLN * rpW / 3) + 1 + 13, pLST + (i + .9) * pSTP, #2962ff80, bgcolor = #2962ff10, 
         text = str.tostring(pLST + (i + .5) * pSTP, format.mintick), text_color = chart.fg_color, text_size = size.auto ))

    for i = 0 to 25 - 1
        if dRP.size() < 500
            vtLV = rpVST.get(i), vtMX = rpVST.max(), LpM  = vtLV / vtMX, DpM  = rpVSD.get(i) / rpVSD.max()
            llC := LpM > 53 ? color.from_gradient(LpM, 53, 1, color.new(#2962ff, 50), color.new(#ffeb3b, 50)) : color.from_gradient(LpM, 0, 37, color.new(#f23645, 50), color.new(#2962ff, 50))
            bbp = 2 * rpVSB.get(i) - vtLV
            lsC := bbp > 0 ? color.from_gradient(DpM, 0, .7, color.new(color.new(#26a69a, 50), 70 + int(73 / 4)), color.new(color.new(#26a69a, 50), 30 + int(73 / 4))) : 
             color.from_gradient(DpM, 0, .7, color.new(color.new(#ef5350, 50), 70 + int(73 / 4)), color.new(color.new(#ef5350, 50), 30 + int(73 / 4)))
            if LpM == 1
                dRP.push(box.new((b[rpLN]).i, pLST + (rpVST.indexof(vtMX) + .0) * pSTP, b.i, pLST + (rpVST.indexof(vtMX) + 1.) * pSTP, color.new(#ffeb3b, 50), bgcolor = color.new(color.new(#ffeb3b, 50), 73) ))
            sBI = b.i + rpLN * rpW
            dRP.push(box.new(sBI + 13, pLST + (i + .1) * pSTP, sBI - int(DpM * rpLN * rpW)  + 13, pLST + (i + .9) * pSTP, lsC, bgcolor = lsC, 
             text = str.tostring(bbp, format.volume ) + ' (' + str.tostring(math.abs(bbp / vtLV * 100), '#.##') + '%)', 
             text_halign =  text.align_right, text_color = chart.fg_color, text_size = size.auto ))
