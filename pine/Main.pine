//@version=6
indicator(title="Main Chart [AC]", shorttitle='1', overlay=true, max_bars_back=5000, max_lines_count=500, max_labels_count=500, max_boxes_count=500)

// a - EMA
a=input.bool(true,title='EMA'), plot(a?ta.ema(close,21):na,color=#ff0000), plot(a?ta.ema(close,50):na,color=#ffff00), plot(a?ta.ema(close,200):na,color=#ffffff)

// b - EMA Extra
b=input.bool(false,title='EMA Extra'), plot(b?ta.ema(close,7):na,color=#00ff40), plot(b?ta.ema(close,100):na,color=#ffff88)

// c - Bollinger Band (BB)
c=input.bool(false,title='Bollinger Bands'), c0=0.0, c1=0.0, if c
    c0:=ta.sma(close,7), c1:=2.0*ta.stdev(close,7)
plot(c?c0+c1:na,color=#cccccc), plot(c?c0-c1:na,color=#cccccc)

// d - Parabolic SAR
plot(input.bool(false,title='Parabolic SAR')?ta.sar(0.01,0.01,0.3):na, style=plot.style_cross, color=#cccccc)

// e - Pivot Points
e=input.bool(false,title='Pivot'), e0=ta.pivothigh(10,10), e1=ta.pivotlow(10,10), if not na(e0)and e
    label.new(bar_index[10],e0,str.tostring(e0),style=label.style_label_down)
if not na(e1)and e
    label.new(bar_index[10],e1,str.tostring(e1),style=label.style_label_up)

// f - DeMark Sequential
f=input.bool(false,title='DeMark'), crossover=false, crossunder=false, if f
    int uc=0, dc=0, for i=0 to 8
        uc+=(nz(close[i])>nz(close[i+4])?1:0), dc+=(nz(close[i])<nz(close[i+4])?1:0)
    drp=dc==9?1:uc==9?-1:0, crossover:=ta.crossover(drp,0), crossunder:=ta.crossunder(drp,0)
plotshape(f and crossover,'',shape.labelup,location.belowbar,#00ff00), plotshape(f and crossunder,'',shape.labeldown,location.abovebar,#ff0000)

// g - Ichimoku Cloud
g = input.bool(false,title='Ichimoku Cloud'), g0=0.0, g1=0.0, g2=0.0, g3=0.0, if g
    g0:=(ta.highest(9)+ta.lowest(9))/2, g1:=(ta.highest(26)+ta.lowest(26))/2, g2:=(g0+g1)/2,g3:=(ta.highest(52)+ta.lowest(52))/2
plot(g?g0:na,color=#2962FF),plot(g?g1:na,color=#b71c1c), plot(g?close:na,offset=-25,color=#43a047), fill(plot(g?g2:na,offset=25,color=#a5d6a7), plot(g?g3:na,offset=25,color=#ef9a9a),color=g2>g3?#43a0471a:#f443361a)

// h - Volume Profile 
H0(_a, _b)=>math.round(_a/float(_b/200*5))
if input.bool(true,title="Volume Profile")
    var line h0=na, var line h1=na, var line h2=na, var array<line> h3=array.new_line(), var array<float> h4=array.new_float(200,0), float h5=ta.lowest(low,200), h6=(ta.highest(high,200)-h5)/199
    if barstate.isfirst
        for _i = 0 to 199
            array.push(h3,line.new(x1=bar_index,y1=close,x2=bar_index,y2=close))
        h0:=line.new(x1=bar_index,y1=close,x2=bar_index,y2=close,color=#ff0000), h1:=line.new(x1=bar_index,y1=close,x2=bar_index,y2=close,color=#2962FF), h2:=line.new(x1=bar_index,y1=close,x2=bar_index,y2=close,color=#2962FF)
    if barstate.islast
        array.fill(h4,0), for _i = 0 to 199
            for _j=0 to 199
                float _a=h5+h6*_j, if (_a>=low[_i] and _a<high[_i])
                    array.set(h4,_j,h4.get(_j)+volume[_i])
        float h7=h4.max(), int h8=h4.indexof(h7), h9=bar_index+70, for _i=0 to 199
            _a=h3.get(_i), float _b=h5+h6*_i, line.set_xy1(_a,h9 - H0(h4.get(_i),h7),_b),line.set_xy2(_a,h9,_b),line.set_color(_a,h8==_i?#ff0000:#cccccc)
        float ha=h5+h6*h8,hb=h7, int hc=h8,hd=h8, line.set_xy1(h0,bar_index-200,ha), line.set_xy2(h0,h9-H0(h7,h7)-10,ha), while hb<h4.sum()*0.68
            float _a=(hc<199)?h4.get(hc+1):0.0, _b=(hd>0)?h4.get(hd-1):0.0, if _a==0 and _b==0
                break
            if _a>=_b
                hb+=_a, hc+=1
            else
                hb+=_b, hd-=1
        for _i=hd to hc
            if _i!=h8
                line.set_color(h3.get(_i),#2962FF)
        int he=bar_index-200, float hf=h5+h6*hc, hg=h5+h6*hd, hh=h9-H0(h4.get(hc),h7)-10, line.set_xy1(h1,he,hf), line.set_xy1(h2,he,hg), line.set_xy2(h1,hh,hf), line.set_xy2(h2,hh,hg)

// l - Supertrend
l=input.bool(false,title="Supertrend"), [l0,l1]=ta.supertrend(3.0,10), l2=barstate.isfirst?na:l0,l3=plot(l?barstate.isfirst?na:(open+close)/2:na), fill(l3,plot(l1<0 and l?l2:na,color=#00ff00,style=plot.style_linebr),color=#00ff001a), fill(l3,plot(l1>=0 and l?l2:na,color=#ff0000,style=plot.style_linebr),color=#ff00001a)

// m - VWAP Period
plot(input.bool(false,title="VWAP Period")?math.sum((high+low+close)/3*volume,14)/math.sum(volume,14):na)

// n = Volume
plot(input.bool(false,title='Volume')?volume:na,style=plot.style_columns,color=open>close?#b03838:#008060)

// o - Liqudity Swing
o4=bar_index
O0(_a,_b,_c)=>
    var _e=0, var _d=0., if _a>0
        _e := 0, _d := 0.
    else
        _d += low[14] < _b and high[14] > _c ? volume[14] : 0, _e += low[14] < _b and high[14] > _c ? 1 : 0
    [_e, _d]
O1(_g, _a, _b, _c, _d, _e)=>
    var label _f = na, if ta.crossover(_g, 0)
        _f := label.new(_b, _c, str.tostring(_a, format.volume), style=_e, size=size.tiny, color=#00000000, textcolor=_d)
    if _g > 0
        label.set_text(_f, str.tostring(_a, format.volume))
O2(_a, _b, _c, _d, _e)=>
    var line _f = na, if _a > 0
        if _d[1] < 0
            line.delete(_f[1])
        else if not _b[1]
            line.set_x2(_f, o4 - 14)
        _f := line.new(o4 - 14, _c, o4, _c, color = na)
    if not _b[1]
        line.set_x2(_f, o4+3)
    if _b and not _b[1]
        line.set_x2(_f, o4), line.set_style(_f, line.style_dashed)
    if _d > 0
        line.set_color(_f, _e)
O3(_a, _b, _c, _d, _e)=>
    var box bx = na, if ta.crossover(_d, 0)
        bx := box.new(_a, _b, _a + _d, _c, border_color = na, bgcolor = _e)
    if _d > 0
        box.set_right(bx, _a + _d)
if input.bool(true, title="Liqudity Swing")
    var float o5=na, var float o6=na, var float o7=na, var float o8=na, var bool o9=false, var bool oa=false, var ob=0,var oc=0,of=ta.pivothigh(14,14), [og,oh]=O0(of,o5,o6), var box oe=box.new(na,na,na,na,bgcolor=#ff000033), var box ol=box.new(na,na,na,na,bgcolor=#00897b33), if of>0
        o5:=high[14], o6:=math.max(close[14],open[14]), ob:=o4-14, o9:=false, box.set_lefttop(oe,ob,o5), box.set_rightbottom(oe,ob,o6)
    else
        o9 := close > o5 ? true : o9
        if o9
            box.set_right(oe, ob)
        else
            box.set_right(oe, o4+3)
    O3(ob,o5,o6,og,#ff0000), O2(of,o9,o5,og,#ff0000), O1(og,oh,ob,o5,#ff0000,label.style_label_down), oi=ta.pivotlow(14,14), [oj,ok]=O0(oi,o7,o8), if oi>0
        o7 := math.min(close[14],open[14]), o8:=low[14], oc:=o4-14, oa:=false, box.set_lefttop(ol,oc,o7), box.set_rightbottom(ol,oc,o8)
    else
        oa:=close<o8?true:oa, if oa
            box.set_right(ol, oc)
        else
            box.set_right(ol, o4+3)
    O3(oc, o7, o8, oj, #00897b), O2(oi, oa, o8, oj, #00897b), O1(oj, ok, oc, o8, #00897b, label.style_label_up)

// p - Money Flow Profile
type bar
    float o = open
    float h = high
    float l = low
    float c = close
    float v = volume
    int i = bar_index
p0 = last_bar_index > 200 ? 199 : last_bar_index, bar p1 = bar.new(), p2 = array.new_float(25, 0.), p3 = array.new_float(25, 0.), p4 = array.new_float(25, 0.)
var p5 = array.new_box(), var p6 = array.new<chart.point>(), var color p7 = na, var color p8 = na, p9 = p1.c > p1.o, pa  = nz(p1.v), var float pb = na, var float pc = na
if p1.i == last_bar_index - p0
    pb := p1.l, pc := p1.h
else if p1.i > last_bar_index - p0
    pb := math.min(p1.l, pb), pc := math.max(p1.h, pc)
pd = (pc - pb) / 25
if input.bool(false, title="Money Flow Profile") and barstate.islast and not na(pa) and not timeframe.isseconds and p0 > 0 and pd > 0 and pa > 0
    if p5.size() > 0
        for i = 0 to p5.size() - 1
            box.delete(p5.shift())
    if p6.size() > 0
        p6.clear()
    for j = p0 to 0
        i = 0
        for k = pb to pc - pd by pd
            if (p1[j]).h >= k and (p1[j]).l < k + pd
                vPOR = if (p1[j]).l >= k and (p1[j]).h > k + pd
                    (k + pd - (p1[j]).l) / ((p1[j]).h - (p1[j]).l)
                else if (p1[j]).h <= k + pd and (p1[j]).l < k
                    ((p1[j]).h - k) / ((p1[j]).h - (p1[j]).l)
                else if ((p1[j]).l >= k and (p1[j]).h <= k + pd)
                    1
                else
                    pd / ((p1[j]).h - (p1[j]).l)
                p2.set(i, p2.get(i) + pa[j] * vPOR )
                if p9[j]
                    p3.set(i, p3.get(i) + pa[j] * vPOR )
            i += 1
        p6.push(chart.point.from_index((p1[j]).i, pb + (p2.indexof(p2.max()) + .5) * pd))
    for i = 0 to 25 - 1
        _e = 2*p3.get(i)-p2.get(i), p4.set(i, p4.get(i)+_e*(_e>0?1:-1) ), _f=p1.i+p0*13/100+int(p0*13/100/3), p5.push(box.new(_f-1+13,pb+(i+.1)*pd, _f-int(p0*13/100/3)+14, 
         pb+(i+.9)*pd,#2962ff80,bgcolor=#2962ff10,text=str.tostring(pb+(i+.5)*pd,format.mintick),text_color=chart.fg_color,text_size=size.auto))
    for i = 0 to 25 - 1
        if p5.size() < 500
            _a=p2.get(i), _b=p2.max(), _c =_a/_b, _d=p4.get(i)/p4.max()
            p7 := _c>53/100?color.from_gradient(_c,53/100,1,#2962ff80,#ffeb3b80):color.from_gradient(_c,0,37/100,#f2364580,#2962ff80)
            _e = 2*p3.get(i)-_a
            p8 := _e>0?color.from_gradient(_d,0,.7,color.new(#26a69a80,70+int(73/4)),color.new(#26a69a80,30+int(73/4))) : 
             color.from_gradient(_d,0,.7,color.new(#ef535080,70+int(73/4)),color.new(#ef535080,30+int(73/4)))
            if _c == 1
                p5.push(box.new((p1[p0]).i,pb+(p2.indexof(_b)+.0)*pd,p1.i,pb+(p2.indexof(_b)+1.)*pd,#ffeb3b80,bgcolor=#ffeb3b45))
            _f = p1.i+p0*13/100+int(p0*13/100/3), p5.push(box.new(_f+13,pb+(i+.1)*pd,_f+int(_c*p0*13/100)+13,pb+(i+.9)*pd,p7,bgcolor=p7, 
             text=str.tostring(array.get(p2,i)*(pb+(i+.5)*pd),format.volume)+' ('+str.tostring(math.abs(_a/p2.sum()*100),'#.##')+'%)',text_halign=text.align_left,text_color=chart.fg_color,text_size=size.auto))
            _f := p1.i+p0*13/100, p5.push(box.new(_f+13,pb+(i+.1)*pd,_f-int(_d*p0*13/100)+13,pb+(i+.9)*pd,p8,bgcolor=p8,
             text=str.tostring(_e,format.volume)+' ('+str.tostring(math.abs(_e/_a*100),'#.##')+'%)',text_halign=text.align_right,text_color=chart.fg_color,text_size=size.auto))

// q - Breaker Blocks
q0=last_bar_index-bar_index<=2000, q1=math.max(close,open), q2=math.min(close,open), q3=bar_index, q4=high, q5=low
type Q0 
    int[] d
    int[] x 
    float[] y
    bool[] b
type Q1 
    int a
type Q2
    int a
    bool b
    bool c
    box d
    box e
    line f
    line g
    line h
    bool i
    bool j
    box k
    line l
    label m
    box n
    line o    
    label p
    bool q
    bool r
    bool s
    label t
    label[] u
var Q0 q6 = Q0.new(array.new<int>(50,0), array.new<int>(50,0), array.new<float>(50,na), array.new<bool>(50,false)), var Q1 q8 = Q1.new(0)
var Q2 q7=Q2.new(d=box.new(na,na,na,na,border_color=na), e=box.new(na,na,na,na,border_color=na,text_size=size.small,text_halign=text.align_right)
 , f=line.new(na,na,na,na,style=line.style_dashed,color=#b2b5be), l=line.new(na,na,na,na,color=#b2b5be), m=label.new(na,na,color=na)
 , n=box.new(na,na,na,na,border_color=na), o=line.new(na,na,na,na,color=#b2b5be), p=label.new(na,na,color=na), g=line.new(na,na,na,na,color=#b2b5be)
 , h=line.new(na,na,na,na,color=#b2b5be), t=label.new(na,na,color=na,textcolor=#b2b5be,yloc=yloc.price), u=array.new<label>(1,label(na)))
method Q3(Q0 a, int b, int c, float d, bool e) => a.d.unshift(b), a.x.unshift(c), a.y.unshift(d), a.b.unshift(e), a.d.pop(), a.x.pop(), a.y.pop(), a.b.pop()
method Q4(color a) => color.rgb(color.r(a), color.g(a), color.b(a))
Q5(string a, float b, color c, string d, string e = size.small) =>      
    label.new(q3, b, style=a == 'c' ? label.style_label_center : a == 'u' ? label.style_label_up : label.style_label_down, textcolor=c, color=na, size=e, text=d)
if input.bool(true, title="Breaker Blocks")
    max_bars_back(time, 1000), var float q9=na, var float qa=na, var int qb=q6.d.size(), qc=bar_index-1, qd=ta.pivothigh(q4,5,1), qe=ta.pivotlow(q5,5,1)
    if qd > 0   
        i=q6.d.get(0), q9:=q6.y.get(0), qa:=nz(q4[1])
        if i < 1 
            q6.Q3(1, qc, qa, true)
        else
            if i ==  1 and qd > q9 
                q6.x.set(0, qc), q6.y.set(0, qa)     
    if qe > 0 
        i=q6.d.get(0), q9:=q6.y.get(0), qa:=nz(q5[1])
        if i > -1
            q6.Q3(-1, qc, qa, true)
        else
            if i == -1 and qe < q9 
                q6.x.set(0, qc), q6.y.set(0, qa)
    qf = q6.d.get(2) == 1 ? 2 : 1, qg = q6.d.get(2) == -1 ? 2 : 1
    switch
        close > q6.y.get(qf) and q6.d.get(qf) == 1 and q8.a < 1 and q0 =>
            qh=q6.x.get(qf-1), qi=q6.y.get(qf-1), qj=q6.x.get(qf), qk=q6.x.get(qf+1), ql=q6.y.get(qf+1)
            if qi < ql and qk != qj 
                for i = q3 - qj to q3 - qk
                    if close[i] > open[i]
                        q7.k.set_lefttop(na,na),q7.l.set_xy1(na,na),q7.m.set_xy(na,na), q7.n.set_lefttop(na,na),q7.o.set_xy1(na,na),q7.p.set_xy(na,na)
                        while q7.u.size() > 0
                            q7.u.pop().delete()
                        q7.a:=1, q7.d.set_left(q3-i), q7.d.set_top(q1[i]), q7.d.set_right(q3), q7.d.set_bottom(q2[i]), q7.d.set_bgcolor(#0cb51a12)
                        q7.e.set_left(q3), q7.e.set_top(q1[i]), q7.e.set_right(q3+8), q7.e.set_bottom(q2[i]), q7.e.set_bgcolor(#0cb51a26)
                        q7.e.set_text('+BB'), q7.e.set_text_color(#0cb51a26.Q4()), q7.e.set_text_valign(text.align_bottom), _0=math.avg(q2[i], q1[i])
                        q7.f.set_xy1(q3,_0), q7.f.set_xy2(q3,_0), q7.g.set_xy1(qk, ql), q7.g.set_xy2(q3,ql), q7.h.set_xy1(qh,qi), q7.h.set_xy2(q3,qi)
                        q7.i:=false, q7.j:=false, q7.t.set_xy(qh, qi), q7.t.set_style(label.style_label_up), q7.t.set_text('LL')
                        q7.b:=false, q7.c:=false, q7.s:=false, q7.q:=false, q7.r:=false, _1=0, _2=high
                        for c = 0 to qb -2
                            _3=q6.x.get(c), _4=q6.y.get(c)
                            if _4>_2 and q6.d.get(c)==1
                                _5=(high[q3-_3]-q2[q3-_3])/4
                                switch _1
                                    0 =>
                                        q7.k.set_lefttop(_3,_4), q7.l.set_xy1(_3,_4), q7.k.set_rightbottom(q3,_4-_5), q7.l.set_xy2(q3,_4)
                                        q7.k.set_bgcolor(#0cb51a26), q7.m.set_xy(_3,_4), q7.m.set_size(size.small), q7.m.set_textcolor(#b2b5be)
                                        q7.m.set_text('Premium PDA'), q7.m.set_style(label.style_label_lower_left), _1:=1, _2:=_4
                                    1 =>
                                        if _4-_5>_2
                                            q7.n.set_lefttop(_3,_4), q7.o.set_xy1(_3,_4), q7.n.set_rightbottom(q3,_4-_5), q7.o.set_xy2(q3,_4)
                                            q7.n.set_bgcolor(#0cb51a26), q7.p.set_xy(_3,_4), q7.p.set_size(size.small), q7.p.set_textcolor(#b2b5be)
                                            q7.p.set_text('Premium PDA'), q7.p.set_style(label.style_label_lower_left), _1:=2
                            if _1 == 2
                                break
                        q7.u.unshift(Q5('u', low, #0cb51a26.Q4(), '▲', size.large)), break
            q8.a :=  1
        close < q6.y.get(qg) and q6.d.get(qg) == -1 and q8.a > -1 and q0 =>
            qh=q6.x.get(qg-1), qi=q6.y.get(qg-1), qj=q6.x.get(qg), qk=q6.x.get(qg+1), ql=q6.y.get(qg+1)
            if qi > ql and qk != qj
                for i = q3 - qj to q3 - qk
                    if close[i] < open[i]
                        q7.k.set_lefttop(na,na),q7.l.set_xy1(na,na),q7.m.set_xy(na,na), q7.n.set_lefttop(na,na),q7.o.set_xy1(na,na),q7.p.set_xy(na,na)
                        while q7.u.size() > 0
                            q7.u.pop().delete()
                        q7.a:=-1, q7.d.set_left(q3-i), q7.d.set_top(q1[i]), q7.d.set_right(q3), q7.d.set_bottom(q2[i]), q7.d.set_bgcolor(#ff11000d)
                        q7.e.set_left(q3), q7.e.set_top(q1[i]), q7.e.set_right(q3+8), q7.e.set_bottom(q2[i]), q7.e.set_bgcolor(#ff110026)
                        q7.e.set_text('-BB'), q7.e.set_text_color(#ff110026.Q4()), q7.e.set_text_valign(text.align_top), _0=math.avg(q2[i],q1[i])
                        q7.f.set_xy1(q3,_0), q7.f.set_xy2(q3,_0), q7.g.set_xy1(qk,ql), q7.g.set_xy2(q3,ql), q7.h.set_xy1(qh, qi), q7.h.set_xy2(q3,qi)
                        q7.j:=false, q7.t.set_xy(qh, qi), q7.t.set_style(label.style_label_down), q7.t.set_text('HH'), q7.t.set_textcolor(#b2b5be)   
                        q7.i:=false, q7.b:=false, q7.c:=false, q7.s:=false, q7.q:=false, q7.r:=false, _1=0, _2=low
                        for c = 0 to qb -2
                            _3=q6.x.get(c), _4=q6.y.get(c)
                            if _4<_2 and q6.d.get(c)==-1
                                _5=(q1[q3-_3]-low[q3-_3])/4
                                switch _1 
                                    0 =>
                                        q7.k.set_lefttop(_3,_4+_5), q7.l.set_xy1(_3,_4), q7.k.set_rightbottom(q3,_4), q7.l.set_xy2(q3,_4)
                                        q7.k.set_bgcolor(#00897b26), q7.m.set_xy(_3,_4), q7.m.set_size(size.small), q7.m.set_textcolor(#b2b5be)
                                        q7.m.set_text('Discount PDA'), q7.m.set_style(label.style_label_upper_left), _1:=1, _2:=_4
                                    1 => 
                                        if _4 + _5 < _2
                                            q7.n.set_lefttop(_3,_4+_5), q7.o.set_xy1(_3,_4), q7.n.set_rightbottom(q3,_4), q7.o.set_xy2(q3,_4)
                                            q7.n.set_bgcolor(#00897b26), q7.p.set_xy(_3,_4), q7.p.set_size(size.small), q7.p.set_textcolor(#b2b5be)
                                            q7.p.set_text('Discount PDA'), q7.p.set_style(label.style_label_upper_left), _1:=2
                            if _1 == 2
                                break                    
                        q7.u.unshift(Q5('d', high, #ff110026.Q4(), '▼', size.large)), break       
            q8.a := -1 
    qm=q7.e.get_top(), qn=q7.e.get_bottom(), qo=q7.f.get_y2(), qp=q7.g.get_y2(), qq=q7.h.get_y2()
    switch q7.a
        1  => 
            if not q7.c
                if close < qn
                    q7.c:=true, q7.u.unshift(Q5('u',low,#ffeb3b,'●')), q7.e.set_right(q3), q7.f.set_x2(q3)
                else
                    q7.e.set_right(q3+8), q7.f.set_x2(q3+8)
                if q3 > q7.e.get_left()
                    if not q7.b
                        switch
                            open > qo and open < qm and close > qm => 
                                q7.s:=true, q7.u.unshift(Q5('u',low,#00e676,'▲',size.normal))
                            close < qo and close > qn => 
                                q7.b:=true, q7.s:=false, q7.u.unshift(Q5('u',low,#ff9800,'❌'))
            if not q7.i
                q7.g.set_x2(q3)
                if close < qp
                    q7.i := true                     
            if not q7.j 
                q7.h.set_x2(q3)
                if close < qq
                    q7.j := true                    
            if not q7.q
                q7.k.set_right(q3), q7.l.set_x2(q3)
                if close > q7.k.get_top() and q3 > q7.k.get_left()
                    q7.q := true
            if not q7.r
                q7.n.set_right(q3), q7.o.set_x2(q3)
                if close > q7.n.get_top() and q3 > q7.n.get_left()
                    q7.r := true
        -1 =>
            if not q7.c
                if close > qm
                    q7.c:=true, q7.e.set_right(q3), q7.f.set_x2(q3)
                else
                    q7.e.set_right(q3+8), q7.f.set_x2(q3+8)
                if q3 > q7.e.get_left()
                    if not q7.b
                        switch
                            open < qo and open > qn and close < qn => 
                                q7.s:=true, q7.u.unshift(Q5('d',high,#ff9800,'▼',size.normal))
                            close > qo and close < qm => 
                                q7.b:=true, q7.s:=false, q7.u.unshift(Q5('d',high,#ff5252,'❌'))
            if not q7.i             
                q7.g.set_x2(q3)
                if close > qp                 
                    q7.i := true
            if not q7.j             
                q7.h.set_x2(q3)
                if close > qq
                    q7.j := true
            if not q7.q
                q7.k.set_right(q3), q7.l.set_x2(q3)
                if close < q7.k.get_bottom() and q3 > q7.k.get_left()
                    q7.q := true
            if not q7.r
                q7.n.set_right(q3), q7.o.set_x2(q3)
                if close < q7.n.get_bottom() and q3 > q7.n.get_left()
                    q7.r := true

// r - Harmonics
import reees/TA/85 as t
import reees/Draw/27 as draw
import reees/Utilities/5 as u
import reees/Pattern/1 as p
import reees/Obj_XABCD_Harmonic/10 as h
var int[] r0=array.new_int(), var r1="% of distance to target 1, beyond entry", var h.harmonic_params r2=h.init_params(15.0,255.0,r0,4.0,2.0,3.0)
var h.xabcd_harmonic[] r3=array.new<h.xabcd_harmonic>(), var h.xabcd_harmonic[] r4=array.new<h.xabcd_harmonic>(), if barstate.isfirst
    array.push(r0,1), array.push(r0,2), array.push(r0,3), array.push(r0,4), array.push(r0,5), array.push(r0,6)
R0(_a,_b) => array.new<h.xabcd_harmonic>()
R1(tp) => switch tp
    6 => ".618 CD"
    5 => ".382 AD"
    4 => ".618 AD"
    3 => ".618 AD"
    2 => ".618 AD"
    => ".618 AD"
R2(tp) => switch tp
    6 => "1.618 XA"
    5 => "C"
    4 => "1.618 AD"
    3 => "1.272 AD"
    2 => "1.272 AD"
    => "1.272 AD"
R3(h.xabcd_harmonic _a) => not na(_a.d.x) ? _a.score < 0.9 : _a.score < .9
R4(_a) => h.erase_pattern(_a), h.erase_label(_a)
R5(_a,_b=0) => if _a >= _b
    v = low[_b], for i=_b to _a
        if low[i] < v
            v := low[i]
    v
R6(_a,_b=0) => if _a >= _b
    v = high[_b], for i=_b to _a
        if high[i] > v
            v:=high[i]
    v
R7(_a) => h.draw_pattern(_a, _a.bull?#4caf50cc:#ff5252cc), if _a.invalid_d
    line.set_style(array.get(_a.pLines,3),line.style_dashed)
R8(_a) => h.set_target(_a,1,calc_target=R1(_a.tp)), h.set_target(_a,2,calc_target=R2(_a.tp))
R9(_a, _b=false) => if R3(_a) == false
    array.push(R0(_a.bull, _a.tp), _a), if _b == false
        _c=str.tostring(_a.tp)+"_"+str.tostring(_a.x.x)+"_"+str.tostring(_a.a.x)+"_"+str.tostring(_a.b.x)+"_"+str.tostring(_a.c.x), n=array.size(r4), if not na(_c) and n > 0
            for j=0 to n-1
                _p = array.get(r4,j), if _c == _p.pid
                    array.remove(r4,j), R4(_p), break
        _a.invalid_d := false
    R8(_a), R7(_a), [_d,_e]=t.harmonic_xabcd_przRange(_a.prz_bN,_a.prz_bF,_a.prz_xN,_a.prz_xF), _a.stop:=t.harmonic_xabcd_stop(r1,75,_a.bull,_a.x.y,_a.d.y,_d,_e,_a.t1,_a.e.y), if R3(_a)==false
        array.push(r3, _a)
RA(_a,_b,_c) => if _b <= (int((_a.c.x-_a.x.x)/3*3.55) + _a.c.x)
    if t.pat_xabcd_testSym(_a.a.x-_a.x.x, _a.b.x-_a.a.x, _a.c.x-_a.b.x, _a.d.x-_a.c.x, 255.0)
        _d=R6(bar_index-_a.c.x,1), _e=R5(bar_index-_a.c.x,1), if ((_a.bull and _c<=_e)or(_a.bull==false and _c>=_d))and((_a.bull and _a.c.y>=_d)or(_a.bull==false and _a.c.y<=_e))
            _f = switch _a.tp
                1 => array.from(true,false,false,false,false,false)
                2 => array.from(false,true,false,false,false,false)
                3 => array.from(false,false,true,false,false,false)
                4 => array.from(false,false,false,true,false,false)
                5 => array.from(false,false,false,false,true,false)
                6 => array.from(false,false,false,false,false,true)
            [_g,_h,_i,_j,_k,_l] = t.test_cd(math.abs(_a.c.y-_c),math.abs(_a.b.y-_a.c.y),math.abs(_a.x.y-_a.a.y),math.abs(_a.x.y-_a.c.y),math.abs(_a.a.y-_c),15.0,_f), _g or _h or _i or _j or _k or _l
        else
            false
    else
        false
else
    false
RB(_a,_b=true) => [_c,_d,_e,_f,_g,_h,_i,_j,_k]=t.pat_xabcdIncomplete(_b,_a), if _c and bar_index>=last_bar_index-100 
    [_l,_m,_n,_o,_p,_q,_r]=t.harmonic_xabcd_validateIncomplete(_d,_e,_f,_g,_h,_i,_j,_k,15.0,255.0,true,true,true,true,true,true), if _l
        _s=false, _t=array.size(r4), _u=array.size(r3), if _t>0
            for i=0 to _t-1
                _v=array.get(r4,_t-1-i), if _v.x.x==_d and _v.a.x==_f and _v.b.x==_h
                    if _v.c.x == _j
                        _s := true
                    else
                        array.remove(r4,_t-1-i), R4(_v)
                    break
        if _s==false and _u > 0
            for i=0 to _u-1
                _v=array.get(r3,_u-1-i), if _v.x.x==_d and _v.a.x==_f and _v.b.x==_h and _v.c.x==_j
                    _s:=true, break
        if _s==false
            _w=R5(bar_index-_j), _x=R6(bar_index-_j), int _y=na, float _z=na, for _A in u.boolToIntArr(array.from(_m,_n,_o,_p,_q,_r))
                if _s == false
                    _C=h.init(_d,_e,_f,_g,_h,_i,_j,_k,_y,_z,r2,na), if not na(_C)
                        [_,_D,_] = if R3(_C)
                            [na,na,na]
                        else
                            t.harmonic_xabcd_entry(_C.bull,_C.tp,_C.x.y,_C.a.y,_C.b.y,_C.c.y,_C.d.y,true,"PRZ",true,1.0)
                        if na(_D) or (not na(_D) and ((_b and _D < _w) or (_b==false and _D > _x)))
                            _E=R0(_C.bull,_C.tp), h.xabcd_harmonic _F=array.size(_E)==0?na:array.get(_E,array.size(_E)-1), if na(_F)?true:_F.x.x!=_C.x.x or _F.a.x!=_C.a.x or _F.b.x!=_C.b.x
                                array.push(r4,_C), if not na(_D)
                                    R7(_C)
RC(bull=true) => RB(3,bull),RB(4,bull),RB(5,bull),RB(6,bull),RB(7,bull),RB(8,bull),RB(9,bull),RB(10,bull),RB(11,bull),RB(12,bull),RB(13,bull),RB(14,bull),RB(15,bull),RB(16,bull),RB(17,bull),RB(18,bull),RB(19,bull),RB(20,bull)
if input.bool(true, title="Harmonics")
    h.xabcd_harmonic[] _a=array.new<h.xabcd_harmonic>(), if array.size(r4)>0
        for _b in r4
            [_c,_d]=t.harmonic_xabcd_przRange(_b.prz_bN,_b.prz_bF,_b.prz_xN,_b.prz_xF), if bar_index==(_b.c.x+int((_b.c.x-_b.x.x)/3*3.55)+1)or(_b.bull and(high>_b.c.y or low<_d))or(_b.bull==false and(low<_b.c.y or high>_c))
                R4(_b)
            else
                array.push(_a, _b)
    r4:=_a, RC(), RC(false), r5=bar_index[1], bool r6=true, bool r7=true, r8=low, r9=high, if r8[0] < r8[1]
        r6 := false
    if r6
        for ra=2 to 4
            if r8[ra] < r8[1]
                r6 := false
                break
    if r9[0] > r9[1]
        r7 := false
    if r7
        for ra=2 to 4
            if r9[ra] > r9[1]
                r7 := false
                break
    if r6 or r7
        h.xabcd_harmonic[] rb = array.new<h.xabcd_harmonic>(), for rc in r4
            if r6 and rc.bull
                if RA(rc,r5,r8[1])
                    array.push(rb,h.init(rc.x.x,rc.x.y,rc.a.x,rc.a.y,rc.b.x,rc.b.y,rc.c.x,rc.c.y,r5,r8[1],r2,rc.tp))
            if r7 and rc.bull==false
                if RA(rc,r5,r9[1])
                    array.push(rb,h.init(rc.x.x,rc.x.y,rc.a.x,rc.a.y,rc.b.x,rc.b.y,rc.c.x,rc.c.y,r5,r9[1],r2,rc.tp))
        for rc in r3
            if r6 and rc.bull
                if RA(rc,r5,r8[1])
                    array.push(rb,h.init(rc.x.x,rc.x.y,rc.a.x,rc.a.y,rc.b.x,rc.b.y,rc.c.x,rc.c.y,r5,r8[1],r2,rc.tp))
            if r7 and rc.bull==false
                if RA(rc,r5,r9[1])
                    array.push(rb,h.init(rc.x.x,rc.x.y,rc.a.x,rc.a.y,rc.b.x,rc.b.y,rc.c.x,rc.c.y,r5,r9[1],r2,rc.tp))
        for rc in rb
            if not na(rc)
                bool rd=false, h.xabcd_harmonic re=na, rf=R0(rc.bull,rc.tp), if array.size(rf) > 0
                    rg=array.get(rf,array.size(rf)-1), if rc.a.x!=rg.a.x or rc.b.x!=rg.b.x or rc.c.x!=rg.c.x
                        R9(rc), re:=rc
                    else if (rc.bull and rc.d.y < rg.d.y) or (rc.bull==false and rc.d.y > rg.d.y)
                        if (rg.score <= rc.score) or rg.invalid_d
                            if rg.eHit
                                rd := true, R7(rg), R8(rg), re := rg, h.init(rg.x.x,rg.x.y,rg.a.x,rg.a.y,rg.b.x,rg.b.y,rg.c.x,rg.c.y,rc.d.x,rc.d.y,r2,rg.tp,rg)
                                [rh,ri] = t.harmonic_xabcd_przRange(rg.prz_bN,rg.prz_bF,rg.prz_xN,rg.prz_xF), rg.stop := t.harmonic_xabcd_stop(r1,75.0,rg.bull,rg.x.y,rg.d.y,rh,ri,rg.t1,rg.e.y)                                
                            else
                                R4(array.pop(rf)), R9(rc), re := rc
                else
                    R9(rc), re := rc
                if not na(re)
                    if rd
                        draw.eHitLbl(re.e.x,re.e.y,re.d.x,re.d.y,rc.bull,true)
