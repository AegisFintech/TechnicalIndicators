//@version=6
indicator(title="Main Chart [AC]", shorttitle = '1', overlay = true, max_bars_back = 5000, max_lines_count = 500, max_labels_count = 500, max_boxes_count = 500)

// a - EMA
a = input.bool(true, title='EMA')
plot(a ? ta.ema(close, 21) : na, color=#ff0000), plot(a ? ta.ema(close, 50) : na, color=#ffff00)
plot(a ? ta.ema(close, 200) : na, color=#ffffff)

// b - EMA Extra
b = input.bool(false, title='EMA Extra')
plot(b ? ta.ema(close, 7) : na, color=#00ff40), plot(b ? ta.ema(close, 100) : na, color=#ffff88)

// c - Bollinger Band (BB)
c = input.bool(false, title='Bollinger Band (BB)'), c0 = 0.0, c1 = 0.0
if c
    c0 := ta.sma(close, 7), c1 := 2.0*ta.stdev(close, 7)
plot(c ? c0 + c1 : na, color=#cccccc), plot(c ? c0 - c1 : na, color=#cccccc)

// d - Parabolic SAR
plot(input.bool(false, title='Parabolic SAR') ? ta.sar(0.01, 0.01, 0.3) : na, style=plot.style_cross, color=#cccccc)

// e - Pivot Points
e = input.bool(false, title='Pivot'), e0 = ta.pivothigh(10, 10), e1 = ta.pivotlow(10, 10)
if not na(e0) and e
    label.new(bar_index[10], e0, str.tostring(e0), style=label.style_label_down)
if not na(e1) and e
    label.new(bar_index[10], e1, str.tostring(e1), style=label.style_label_up)

// f - DeMark Sequential
f = input.bool(false, title='DeMark'), crossover = false, crossunder = false
if f
    int uc = 0, dc = 0
    for i = 0 to 8
        uc += (nz(close[i]) > nz(close[i + 4]) ? 1 : 0), dc += (nz(close[i]) < nz(close[i + 4]) ? 1 : 0)
    drp = dc == 9 ? 1 : uc == 9 ? -1 : 0, crossover := ta.crossover(drp, 0), crossunder := ta.crossunder(drp, 0)
plotshape(f and crossover, '', shape.labelup, location.belowbar, #00ff00), plotshape(f and crossunder, '', shape.labeldown, location.abovebar, #ff0000)

// g - Ichimoku Cloud
g = input.bool(false, title='Ichimoku Cloud'), g0 = 0.0, g1 = 0.0, g2 = 0.0, g3 = 0.0
if g
    g0 := (ta.highest(9) + ta.lowest(9)) / 2, g1 := (ta.highest(26) + ta.lowest(26)) / 2, g2 := (g0 + g1) / 2, g3 := (ta.highest(52) + ta.lowest(52)) / 2
plot(g ? g0 : na, color=#2962FF), plot(g ? g1 : na, color=#b71c1c), plot(g ? close : na, offset=-25, color=#43a047)
fill(plot(g ? g2 : na, offset=25, color=#a5d6a7), plot(g ? g3 : na, offset=25, color=#ef9a9a), color=g2 > g3 ? color.new(#43a047, 90) : color.new(#f44336, 90))

// h - Volume Profile 
H0(_a, _b) => math.round(_a / float(_b / 200 * 5))
if input.bool(true, title="Volume Profile")
    var line h0 = na, var line h1 = na, var line h2 = na, var array<line> h3 = array.new_line(),
     var array<float> h4 = array.new_float(200, 0), float h5 = ta.lowest(low, 200), h6 = (ta.highest(high, 200) - h5) / 199
    if barstate.isfirst
        for _i = 0 to 199
            array.push(h3, line.new(x1=bar_index, y1=close, x2=bar_index, y2=close))
        h0 := line.new(x1=bar_index, y1=close, x2=bar_index, y2=close, color=#ff0000)
        h1 := line.new(x1=bar_index, y1=close, x2=bar_index, y2=close, color=#2962FF)
        h2 := line.new(x1=bar_index, y1=close, x2=bar_index, y2=close, color=#2962FF)
    if barstate.islast
        array.fill(h4, 0)
        for _i = 0 to 199
            for _j = 0 to 199
                float _a = h5 + h6 * _j
                if (_a >= low[_i] and _a < high[_i])
                    array.set(h4, _j, h4.get(_j) + volume[_i])
        float h7 = h4.max(), int h8 = h4.indexof(h7), h9 = bar_index + 70
        for _i = 0 to 199
            _a = h3.get(_i), float _b = h5 + h6 * _i
            line.set_xy1(_a, h9 - H0(h4.get(_i), h7), _b), line.set_xy2(_a, h9, _b), line.set_color(_a, h8 == _i ? #ff0000 : #cccccc)
        float ha = h5 + h6 * h8, hb = h7, int hc = h8, hd = h8, line.set_xy1(h0, bar_index - 200, ha), line.set_xy2(h0, h9 - H0(h7, h7) - 10, ha)
        while hb < h4.sum() * 0.68
            float _a = (hc < 199) ? h4.get(hc + 1) : 0.0, _b = (hd > 0) ? h4.get(hd - 1) : 0.0
            if _a == 0 and _b == 0
                break
            if _a >= _b
                hb += _a, hc += 1
            else
                hb += _b, hd -= 1
        for _i = hd to hc
            if _i != h8
                line.set_color(h3.get(_i), #2962FF)
        int he = bar_index - 200, float hf = h5 + h6 * hc, hg = h5 + h6 * hd, hh = h9 - H0(h4.get(hc), h7) - 10
        line.set_xy1(h1, he, hf), line.set_xy1(h2, he, hg), line.set_xy2(h1, hh, hf), line.set_xy2(h2, hh, hg)

// l - Supertrend
l = input.bool(false, title="Supertrend"), [l0, l1] = ta.supertrend(3.0, 10)
l2 = barstate.isfirst ? na : l0, l3 = plot(l ? barstate.isfirst ? na : (open + close) / 2 : na)
fill(l3, plot(l1 < 0 and l ? l2 : na, color=#00ff00, style=plot.style_linebr), color=color.new(#00ff00, 90))
fill(l3, plot(l1 >= 0 and l ? l2 : na, color=#ff0000, style=plot.style_linebr), color=color.new(#ff0000, 90))

// m - VWAP Period
plot(input.bool(false, title="VWAP Period") ? math.sum((high+low+close)/3*volume, 14) / math.sum(volume, 14) : na)

// n = Volume
plot(input.bool(false, title='Volume') ? volume : na, style=plot.style_columns, color=open > close ? #b03838 : #008060)

// o - Liqudity Swing
o4 = bar_index
O0(_a, _b, _c)=>
    var _e = 0, var _d = 0.
    if _a > 0
        _e := 0, _d := 0.
    else
        _d += low[14] < _b and high[14] > _c ? volume[14] : 0, _e += low[14] < _b and high[14] > _c ? 1 : 0
    [_e, _d]
O1(_g, _a, _b, _c, _d, _e)=>
    var label _f = na
    if ta.crossover(_g, 0)
        _f := label.new(_b, _c, str.tostring(_a, format.volume), style=_e, size=size.tiny, color=#00000000, textcolor=_d)
    if _g > 0
        label.set_text(_f, str.tostring(_a, format.volume))
O2(_a, _b, _c, _d, _e)=>
    var line _f = na
    if _a > 0
        if _d[1] < 0
            line.delete(_f[1])
        else if not _b[1]
            line.set_x2(_f, o4 - 14)
        _f := line.new(o4 - 14, _c, o4, _c, color = na)
    if not _b[1]
        line.set_x2(_f, o4+3)
    if _b and not _b[1]
        line.set_x2(_f, o4), line.set_style(_f, line.style_dashed)
    if _d > 0
        line.set_color(_f, _e)
O3(_a, _b, _c, _d, _e)=>
    var box bx = na
    if ta.crossover(_d, 0)
        bx := box.new(_a, _b, _a + _d, _c, border_color = na, bgcolor = _e)
    if _d > 0
        box.set_right(bx, _a + _d)
if input.bool(true, title="Liqudity Swing")
    var float o5 = na, var float o6 = na, var float o7 = na, var float o8 = na, var bool o9 = false, var bool oa = false
    var ob = 0, var oc = 0, of = ta.pivothigh(14, 14), [og, oh] = O0(of, o5, o6)
    var box oe = box.new(na,na,na,na, bgcolor=color.new(#ff0000, 80)), var box ol = box.new(na,na,na,na, bgcolor=color.new(#00897b, 80))
    if of > 0
        o5 := high[14], o6 := math.max(close[14], open[14]), ob := o4 - 14, o9 := false
        box.set_lefttop(oe, ob, o5), box.set_rightbottom(oe, ob, o6)
    else
        o9 := close > o5 ? true : o9
        if o9
            box.set_right(oe, ob)
        else
            box.set_right(oe, o4+3)
    O3(ob, o5, o6, og, #ff0000), O2(of, o9, o5, og, #ff0000), O1(og, oh, ob, o5, #ff0000, label.style_label_down), oi = ta.pivotlow(14, 14), [oj, ok] = O0(oi, o7, o8)
    if oi > 0
        o7 := math.min(close[14], open[14]), o8 := low[14], oc := o4 - 14, oa := false, box.set_lefttop(ol, oc, o7), box.set_rightbottom(ol, oc, o8)
    else
        oa := close < o8 ? true : oa
        if oa
            box.set_right(ol, oc)
        else
            box.set_right(ol, o4+3)
    O3(oc, o7, o8, oj, #00897b), O2(oi, oa, o8, oj, #00897b), O1(oj, ok, oc, o8, #00897b, label.style_label_up)

// p - Money Flow Profile
type bar
    float o = open
    float h = high
    float l = low
    float c = close
    float v = volume
    int i = bar_index
p0 = last_bar_index > 200 ? 199 : last_bar_index, bar p1 = bar.new(), p2 = array.new_float(25, 0.), p3 = array.new_float(25, 0.), p4 = array.new_float(25, 0.)
var p5 = array.new_box(), var p6 = array.new<chart.point>(), var color p7 = na, var color p8 = na, p9 = p1.c > p1.o, pa  = nz(p1.v), var float pb = na, var float pc = na
if p1.i == last_bar_index - p0
    pb := p1.l, pc := p1.h
else if p1.i > last_bar_index - p0
    pb := math.min(p1.l, pb), pc := math.max(p1.h, pc)
pd = (pc - pb) / 25
if input.bool(false, title="Money Flow Profile") and barstate.islast and not na(pa) and not timeframe.isseconds and p0 > 0 and pd > 0 and pa > 0
    if p5.size() > 0
        for i = 0 to p5.size() - 1
            box.delete(p5.shift())
    if p6.size() > 0
        p6.clear()
    for j = p0 to 0
        i = 0
        for k = pb to pc - pd by pd
            if (p1[j]).h >= k and (p1[j]).l < k + pd
                vPOR = if (p1[j]).l >= k and (p1[j]).h > k + pd
                    (k + pd - (p1[j]).l) / ((p1[j]).h - (p1[j]).l)
                else if (p1[j]).h <= k + pd and (p1[j]).l < k
                    ((p1[j]).h - k) / ((p1[j]).h - (p1[j]).l)
                else if ((p1[j]).l >= k and (p1[j]).h <= k + pd)
                    1
                else
                    pd / ((p1[j]).h - (p1[j]).l)
                p2.set(i, p2.get(i) + pa[j] * vPOR )
                if p9[j]
                    p3.set(i, p3.get(i) + pa[j] * vPOR )
            i += 1
        p6.push(chart.point.from_index((p1[j]).i, pb + (p2.indexof(p2.max()) + .5) * pd))
    for i = 0 to 25 - 1
        _e = 2*p3.get(i)-p2.get(i), p4.set(i, p4.get(i)+_e*(_e>0?1:-1) ), _f=p1.i+p0*13/100+int(p0*13/100/3), p5.push(box.new(_f-1+13,pb+(i+.1)*pd, _f-int(p0*13/100/3)+14, 
         pb+(i+.9)*pd,#2962ff80,bgcolor=#2962ff10,text=str.tostring(pb+(i+.5)*pd,format.mintick),text_color=chart.fg_color,text_size=size.auto))
    for i = 0 to 25 - 1
        if p5.size() < 500
            _a=p2.get(i), _b=p2.max(), _c =_a/_b, _d=p4.get(i)/p4.max()
            p7 := _c>53/100?color.from_gradient(_c,53/100,1,color.new(#2962ff,50),color.new(#ffeb3b,50)):color.from_gradient(_c,0,37/100,color.new(#f23645,50),color.new(#2962ff,50))
            _e = 2*p3.get(i)-_a
            p8 := _e>0?color.from_gradient(_d,0,.7,color.new(color.new(#26a69a,50),70+int(73/4)),color.new(color.new(#26a69a,50),30+int(73/4))) : 
             color.from_gradient(_d,0,.7,color.new(color.new(#ef5350,50),70+int(73/4)),color.new(color.new(#ef5350,50),30+int(73/4)))
            if _c == 1
                p5.push(box.new((p1[p0]).i,pb+(p2.indexof(_b)+.0)*pd,p1.i,pb+(p2.indexof(_b)+1.)*pd,color.new(#ffeb3b,50),bgcolor=color.new(color.new(#ffeb3b,50),73)))
            _f = p1.i+p0*13/100+int(p0*13/100/3), p5.push(box.new(_f+13,pb+(i+.1)*pd,_f+int(_c*p0*13/100)+13,pb+(i+.9)*pd,p7,bgcolor=p7, 
             text=str.tostring(array.get(p2,i)*(pb+(i+.5)*pd),format.volume)+' ('+str.tostring(math.abs(_a/p2.sum()*100),'#.##')+'%)',text_halign=text.align_left,text_color=chart.fg_color,text_size=size.auto))
            _f := p1.i+p0*13/100, p5.push(box.new(_f+13,pb+(i+.1)*pd,_f-int(_d*p0*13/100)+13,pb+(i+.9)*pd,p8,bgcolor=p8,
             text=str.tostring(_e,format.volume)+' ('+str.tostring(math.abs(_e/_a*100),'#.##')+'%)',text_halign=text.align_right,text_color=chart.fg_color,text_size=size.auto))
