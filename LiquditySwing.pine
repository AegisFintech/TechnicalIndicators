//@version=6
indicator("Liquidity Swing", "2", true, max_bars_back = 1500, max_boxes_count = 500, max_lines_count = 500)

//Style
topCss = input(color.red, '', inline = 'top', group = 'Style')
topAreaCss = input(color.new(color.red, 50), 'Area', inline = 'top', group = 'Style')
btmCss = input(color.teal, '', inline = 'btm', group = 'Style')
btmAreaCss  = input(color.new(color.teal, 50), 'Area', inline = 'btm', group = 'Style')
n = bar_index
get_data()=> [high, low, volume]
[h, l, v] = request.security_lower_tf(syminfo.tickerid, '1', get_data())
get_counts(condition, top, btm)=>
    var count = 0, var vol = 0.
    if condition > 0
        count := 0, vol := 0.
    else
        vol += low[14] < top and high[14] > btm ? volume[14] : 0, count += low[14] < top and high[14] > btm ? 1 : 0
    [count, vol]
set_label(count, vol, x, y, css, lbl_style)=>
    var label lbl = na
    if ta.crossover(count, 0)
        lbl := label.new(x, y, str.tostring(vol, format.volume), style=lbl_style, size=size.tiny, color=#00000000, textcolor=css)
    if count > 0
        label.set_text(lbl, str.tostring(vol, format.volume))
set_level(condition, crossed, value, count, css)=>
    var line lvl = na
    if condition > 0
        if count[1] < 0
            line.delete(lvl[1])
        else if not crossed[1]
            line.set_x2(lvl, n - 14)
        lvl := line.new(n - 14, value, n, value, color = na)
    if not crossed[1]
        line.set_x2(lvl, n+3)
    if crossed and not crossed[1]
        line.set_x2(lvl, n), line.set_style(lvl, line.style_dashed)
    if count > 0
        line.set_color(lvl, css)
set_zone(condition, x, top, btm, count, css)=>
    var box bx = na
    if ta.crossover(count, 0)
        bx := box.new(x, top, x + count, btm, border_color = na, bgcolor = css)
    if count > 0
        box.set_right(bx, x + count)
var float ph_top = na, var float ph_btm = na, var float pl_top = na, var float pl_btm = na
var bool ph_crossed = false, var bool pl_crossed = false, var ph_x1 = 0, var pl_x1 = 0
var box ph_bx = box.new(na,na,na,na, bgcolor=color.new(topAreaCss, 80)), var box pl_bx = box.new(na,na,na,na, bgcolor=color.new(btmAreaCss, 80))
ph = ta.pivothigh(14, 14)
[ph_count, ph_vol] = get_counts(ph, ph_top, ph_btm)
if ph > 0
    ph_top := high[14], ph_btm := math.max(close[14], open[14]), ph_x1 := n - 14, ph_crossed := false
    box.set_lefttop(ph_bx, ph_x1, ph_top), box.set_rightbottom(ph_bx, ph_x1, ph_btm)
else
    ph_crossed := close > ph_top ? true : ph_crossed
    if ph_crossed
        box.set_right(ph_bx, ph_x1)
    else
        box.set_right(ph_bx, n+3)
set_zone(ph, ph_x1, ph_top, ph_btm, ph_count, topAreaCss)
set_level(ph, ph_crossed, ph_top, ph_count, topCss)
set_label(ph_count, ph_vol, ph_x1, ph_top, topCss, label.style_label_down)
pl = ta.pivotlow(14, 14), [pl_count, pl_vol] = get_counts(pl, pl_top, pl_btm)
if pl > 0
    pl_top := math.min(close[14], open[14]), pl_btm := low[14], pl_x1 := n - 14, pl_crossed := false
    box.set_lefttop(pl_bx, pl_x1, pl_top), box.set_rightbottom(pl_bx, pl_x1, pl_btm)
else
    pl_crossed := close < pl_btm ? true : pl_crossed
    if pl_crossed
        box.set_right(pl_bx, pl_x1)
    else
        box.set_right(pl_bx, n+3)
set_zone(pl, pl_x1, pl_top, pl_btm, pl_count, btmAreaCss)
set_level(pl, pl_crossed, pl_btm, pl_count, btmCss)
set_label(pl_count, pl_vol, pl_x1, pl_btm, btmCss, label.style_label_up)


// disp   = display.all - display.status_line
// rpLN  = last_bar_index > 200 ? 200 - 1 : last_bar_index
// vpSRC  = 'Volume'
// vpSH   = true
// vpHVC  = color.new(#ffeb3b, 50)
// vpHVT  = 53
// vpAVC  = color.new(#2962ff, 50)
// vpLVC  = color.new(#f23645, 50)
// vpLVT  = 37
// spSH   = true
// spPTY  = 'Bar Polarity'
// spBLC  = color.new(#26a69a, 50)
// spBRC  = color.new(#ef5350, 50)
// hmSH   = false
// hmSO1  = 'Volume/Money Flow Profile'
// hmSRC  = 'Volume/Money Flow Profile'
// hmTR   = 73
// spPT1  = 'Bar Polarity'
// othGR  = 'Other Presentation Settings'
// rpPC   = 'Last(Zone)'
// vaSH   = false
// vaC    = color.new(#2962ff, 73)
// spPC   = false
// rpPL   = false
// rpPLC  = color.new(#00bcd4, 0)
// rpLS   = 'Small'
// rpBG   = false
// rpBGC  = color.new(#00bcd4, 95)
// rpNR   = 25
// rpW    = 13
// vpHO   = 13

// type bar
//     float o = open
//     float h = high
//     float l = low
//     float c = close
//     float v = volume
//     int   i = bar_index

// bar b = bar.new()

// rpVST = array.new_float(rpNR, 0.)
// rpVSB = array.new_float(rpNR, 0.)
// rpVSD = array.new_float(rpNR, 0.)

// var dRP = array.new_box()
// var pocPoints = array.new<chart.point>()  
// var polyline pocPolyline = na
// var polyline spPolyline = na

// var color llC = na
// var color lsC = na

// f_drawLabelX(_x, _y, _text, _style, _textcolor, _size, _tooltip) =>
//     var lb = label.new(_x, _y, _text, xloc.bar_index, yloc.price, color(na), _style, _textcolor, _size, text.align_left, _tooltip)
//     lb.set_xy(_x, _y)
//     lb.set_text(_text)
//     lb.set_tooltip(_tooltip)
//     lb.set_textcolor(_textcolor)

// f_gTS(_t) =>
//     switch _t
//         'Tiny'   => size.tiny
//         'Small'  => size.small 
//         'Normal' => size.normal
//         'Auto'   => size.auto

// bull = spPTY == spPT1 ? b.c > b.o : (b.c - b.l) > (b.h - b.c)
// nzV  = nz(b.v)
// rpS  = f_gTS(rpLS)
// vpS  = f_gTS('Auto')

// var float pLST = na
// var float pHST = na

// if b.i == last_bar_index - rpLN
//     pLST := b.l 
//     pHST := b.h
// else if b.i > last_bar_index - rpLN
//     pLST := math.min(b.l, pLST)
//     pHST := math.max(b.h, pHST)

// pSTP = (pHST - pLST) / rpNR

// if barstate.islast and not na(nzV) and not timeframe.isseconds and rpLN > 0 and pSTP > 0 and nzV > 0

//     if dRP.size() > 0
//         for i = 0 to dRP.size() - 1
//             box.delete(dRP.shift())

//     if pocPoints.size() > 0
//         pocPoints.clear()
    
//     a_allPolylines = polyline.all
//     if array.size(a_allPolylines) > 0
//         for i = 0 to array.size(a_allPolylines) - 1
//             polyline.delete(a_allPolylines.get(i))

//     for bI = rpLN to 0
//         i = 0
//         for pLL = pLST to pHST - pSTP by pSTP
//             if (b[bI]).h >= pLL and (b[bI]).l < pLL + pSTP
//                 vPOR = if (b[bI]).l >= pLL and (b[bI]).h > pLL + pSTP
//                     (pLL + pSTP - (b[bI]).l) / ((b[bI]).h - (b[bI]).l)
//                 else if (b[bI]).h <= pLL + pSTP and (b[bI]).l < pLL
//                     ((b[bI]).h - pLL) / ((b[bI]).h - (b[bI]).l)
//                 else if ((b[bI]).l >= pLL and (b[bI]).h <= pLL + pSTP)
//                     1
//                 else
//                     pSTP / ((b[bI]).h - (b[bI]).l)

//                 if vpSRC == 'Money Flow'
//                     rpVST.set(i, rpVST.get(i) + nzV[bI] * vPOR * (pLST + (i + .5) * pSTP) )
//                 else
//                     rpVST.set(i, rpVST.get(i) + nzV[bI] * vPOR )

//                 if bull[bI] and spSH
//                     if vpSRC == 'Money Flow'
//                         rpVSB.set(i, rpVSB.get(i) + nzV[bI] * vPOR * (pLST + (i + .5) * pSTP))
//                     else
//                         rpVSB.set(i, rpVSB.get(i) + nzV[bI] * vPOR )
//             i += 1

//         if rpPC == 'Developing'
//             if bI == rpLN
//                 pocPoints.push(chart.point.from_index((b[bI]).i, pLST + (rpVST.indexof(rpVST.max()) + .5) * pSTP))
//             else
//                 pocPoints.push(chart.point.from_index((b[bI]).i, pLST + (rpVST.indexof(rpVST.max()) + .5) * pSTP))

//     if rpPC == 'Developing'           
//         pocPolyline := polyline.new(pocPoints, false, false, xloc.bar_index, vpHVC, color(na), line.style_solid, 2)

//     if rpPC == 'Last(Zone)' or rpPC == 'Last(Line)'
//         pocPoints.push(chart.point.from_index((b[rpLN]).i, pLST + (rpVST.indexof(rpVST.max()) + .5) * pSTP))
//         pocPoints.push(chart.point.from_index(b.i, pLST + (rpVST.indexof(rpVST.max()) + .5) * pSTP))

//         pocPolyline := polyline.new(pocPoints, false, false, xloc.bar_index, vpHVC, color(na), rpPC == 'Last(Line)' ? line.style_solid : line.style_dotted, rpPC == 'Last(Line)' ? 2 : 1)

//     for i = 0 to rpNR - 1
//         bbp  = 2 * rpVSB.get(i) - rpVST.get(i)
//         rpVSD.set(i, rpVSD.get(i) + bbp * (bbp > 0 ? 1 : -1) )

//         if vpSH or spSH
//             sBI = b.i + (spSH ? rpLN * rpW : 7) + int(rpLN * rpW / 3)
//             dRP.push(box.new(sBI - 1 + vpHO, pLST + (i + .1) * pSTP, sBI - int(rpLN * rpW / 3) + 1 + vpHO, pLST + (i + .9) * pSTP, #2962ff80, bgcolor = #2962ff10, 
//                                text = str.tostring(pLST + (i + .5) * pSTP, format.mintick), text_color = chart.fg_color, text_size = vpS ))

//     if rpBG
//         dRP.push(box.new(b.i - rpLN, pLST, b.i, pHST, rpBGC, bgcolor = rpBGC ))

//     if rpPL
//         f_drawLabelX(b.i, pHST, str.tostring(pHST, format.mintick), label.style_label_down, rpPLC, rpS, 
//                      'Profile High - ' + str.tostring(pHST, format.mintick) + '\n %' + str.tostring((pHST - pLST) / pLST * 100, '#.##') + ' higher than the Profile Low\n\n' +
//                      'Total ' + (vpSRC == 'Volume' ? 'Volume : ' : 'Money Flow (' + syminfo.currency + ') : ') + str.tostring(rpVST.sum(), format.volume) +
//                      '\nNumber of bars : ' + str.tostring(rpLN + 1))

//         f_drawLabelX(b.i, pLST, str.tostring(pLST, format.mintick), label.style_label_up  , rpPLC, rpS, 
//                      'Profile Low - '  + str.tostring(pLST, format.mintick) + '\n %' + str.tostring((pHST - pLST) / pHST * 100, '#.##') + ' lower than the Profile High\n\n' +
//                      'Total ' + (vpSRC == 'Volume' ? 'Volume : ' : 'Money Flow (' + syminfo.currency + ') : ') + str.tostring(rpVST.sum(), format.volume) +
//                      '\nNumber of bars : ' + str.tostring(rpLN + 1))

//     for i = 0 to rpNR - 1
//         if dRP.size() < 500
//             vtLV = rpVST.get(i)
//             vtMX = rpVST.max()
//             LpM  = vtLV / vtMX
//             vdMX = rpVSD.max()
//             DpM  = rpVSD.get(i) / vdMX

//             llC := LpM > vpHVT ? color.from_gradient(LpM, vpHVT, 1, vpAVC, vpHVC) : color.from_gradient(LpM, 0, vpLVT, vpLVC, vpAVC)

//             bbp = 2 * rpVSB.get(i) - vtLV
//             lsC := bbp > 0 ? color.from_gradient(DpM, 0, .7, color.new(spBLC, 70 + int(hmTR / 4)), color.new(spBLC, 30 + int(hmTR / 4))) : 
//                              color.from_gradient(DpM, 0, .7, color.new(spBRC, 70 + int(hmTR / 4)), color.new(spBRC, 30 + int(hmTR / 4)))

//             if rpPC == 'Last(Zone)' and LpM == 1
//                 dRP.push(box.new((b[rpLN]).i, pLST + (rpVST.indexof(vtMX) + .0) * pSTP, b.i, pLST + (rpVST.indexof(vtMX) + 1.) * pSTP, vpHVC, bgcolor = color.new(vpHVC, 73) ))

//             if vaSH and LpM > 25 and LpM < 1
//                 dRP.push(box.new((b[rpLN]).i, pLST + (i + .0) * pSTP, b.i, pLST + (i + 1.) * pSTP, color(na), bgcolor = vaC ))

//             if vaSH and rpPC != 'Last(Zone)' and LpM == 1
//                 dRP.push(box.new((b[rpLN]).i, pLST + (i + .0) * pSTP, b.i, pLST + (i + 1.) * pSTP, color(na), bgcolor = vaC ))

//             if spPC and DpM == 1
//                 spPolyline := polyline.new(array.from(chart.point.from_index((b[rpLN]).i, pLST + (rpVSD.indexof(vdMX) + .5) * pSTP), chart.point.from_index(b.i, pLST + (rpVSD.indexof(vdMX) + .5) * pSTP)), false, false, xloc.bar_index, lsC, color(na), line.style_dotted, 1)

//                 dRP.push(box.new((b[rpLN]).i, pLST + (rpVSD.indexof(vdMX) + .0) * pSTP, b.i, pLST + (rpVSD.indexof(vdMX) + 1.) * pSTP, lsC, bgcolor = color.new(lsC, 73) ))

//             if vpSH
//                 sBI  = b.i + (spSH ? rpLN * rpW : 7) + int(rpLN * rpW / 3)
//                 eBI  = sBI + int(LpM * rpLN * rpW)

//                 dRP.push(box.new(sBI + vpHO, pLST + (i + .1) * pSTP, eBI + vpHO, pLST + (i + .9) * pSTP, llC, bgcolor = llC, 
//                                  text = str.tostring(vpSRC == 'Money Flow' ? array.get(rpVST, i) : array.get(rpVST, i) * (pLST + (i + .5) * pSTP), format.volume) + ' ' + 
//                                  syminfo.currency + ' (' + str.tostring(math.abs(vtLV / rpVST.sum() * 100), '#.##') + '%)', 
//                                  text_halign =  text.align_left, text_color = chart.fg_color, text_size = vpS ))

//             if spSH
//                 sBI = b.i + rpLN * rpW
//                 eBI = sBI - int(DpM * rpLN * rpW) 

//                 dRP.push(box.new(sBI + vpHO, pLST + (i + .1) * pSTP, eBI + vpHO, pLST + (i + .9) * pSTP, lsC, bgcolor = lsC, 
//                                  text = str.tostring(bbp, format.volume ) + (vpSRC == 'Money Flow' ? ' ' + syminfo.currency : '') + 
//                                  ' (' + str.tostring(math.abs(bbp / vtLV * 100), '#.##') + '%)', 
//                                  text_halign =  text.align_right, text_color = chart.fg_color, text_size = vpS ))

//             if hmSH
//                 dRP.push(box.new((b[rpLN]).i, pLST + (i + .0) * pSTP, b.i, pLST + (i + 1.) * pSTP, hmSRC == hmSO1 ? color.new(llC, hmTR) : lsC, bgcolor = hmSRC == hmSO1 ? color.new(llC, hmTR) : lsC))
